정규식에서 가장 어려워하는부분이 전방 탐색 확장(Lockahead Assertions) 구문입니다.  
그러나 꼭 필요한 경우가 있으니 알아 두는 것이 좋습니다.

다음 예제를 보며 코드 리뷰를 하겠습니다.
# 전방 탐색의 종류
```python
import re

p = re.compile(".+:")

m = p.search("http://google.com")
print(m.group()) # http:
```
정규식의 패턴은 **".+:"** 으로 문자열을 'https:'로 리턴하였습니다. 만약 ':' 를 제외 하고 출력 한다면 각 그루핑을 포함한 여러 조건이 추가된다면 어떻게 해야할까요?

전방탐색은 다음과 같이 긍정과 부정의 2종류가 있습니다.

- 전방탐색
  - 긍정형 전방탐색 : (?=...) ... 에 해당되는 정규식과 매치, 조건이 통과되어도 문자열이 소비되지 않음
  - 부정형 전방탐색 : (?=!...) ... 에 해당 되지 않아야하며 , 조건이 통과되어도 문자열이 소비되지 않음

# 긍정형 전방 탐색
긍정형 전방 탐색을 사용하면 'http:' 가 아닌 'http'의 결과를 추출해 낼 수 있습니다.

다음 예제를 살펴 보겠습니다.

```python
import re

p = re.compile(".+(?=:)")

m = p.search("http://google.com")
print(m.group()) # http
```

정규식 중에 ":"에 해당하는 긍정 전방 탐색을 적용하였습니다. **(?=:) 사용**  
이렇게 하면 기존 정규식과 검색에서는 동일한 효과를 발휘하지만 ':' 에 해당하는 문자열이 정규식엔진에 의해 포함되지만 검색결과에는 제외 됩니다.  
검색 결과는 ':' 가 제거된 이 후의 값을 출력합니다. 

## 부정형 전방 탐색
우리는 어떤 조건식을 내놓을떼 어떤것을 제외하는 경우의 조건식이 더 간편할 때도 있는것을 잘 알고 있습니다.  
예를 들어 if문 조건식에서도 긍정식의 방향으로만 부정 조건을 찾는다면 조건식의 알고리즘이 상당히 복잡해 지겠죠.    
따라서 부정식을 사용한 제외 케이스 인 경우 코드를 훨씬 간결하게 작성할 수 있습니다.  

다음은 부정형 전방 탐색을 이용해 파일의 확장자명을 파싱하는 경우의 정규식입니다.

> .*[.](?!bat$).$ # 모든문자 '.*' 와 '.'점을가지며 그리고 (?!bat$)을 통해 bat으로 끝나지않는 패턴을 가집니다.

즉 확장자가 bat이 아닌경우에 통과 된다는 말입니다. 

조건이 추가되는 경우는 다음과 같이 작성합니다.

> .*[.](?!bat$|exe$).*$ "확장자 뒤에 모든 문자열을 가지고 오지만 bat과exe로 끝나는 확장자는 추출하지 않는다"는 의미입니다.





  


