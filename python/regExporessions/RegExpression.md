# 정규표현식
___
정규 표현식(Regular Expressions)은 복잡한 문자열을 처리할 때 사용 하는기법입니다.   
정규식을 사용하는 경우 문자열 또는 데이터를 십게 변환 및 추출 할 수 있는 이점 이있습니다.  
정규식 이라고도 합니다.

## 정규식이 필요한 이유

우리는 실제로 수많은 데이터를 다룹니다.
회원가입을 할때에도 개개인이 모두 달라서 데이터를 등록할때 핸드폰 번호를 "010-1234-5678" 일때도 있고 "01012345678" 일때 도 있죠?  
지금이야 웹페이지에서 가입시 어떠한 조건을 만족해야만 처리가 이루어지지만 그렇지 않은경우도 많이 있을 것입니다.

뒤죽박죽 섞인 텍스트의 데이터들이 원하는 010 1234 5678 만 추출하고 나머지 다른 필요없는 규칙들은 제외하고 싶을 때 우리는 정규식을 사용할 수 있습니다.

## 정규식 활용 이해

다음과 같은 문제가 있다고 가정합니다.

```text
    주민등록번호를 포함하고 있는 텍스트가 있습니다. 이 텍스트에 포함된 모든 주민등록번호의 뒷자리를 * 문자로 변경해 봅시다.
```

정규식을 모르고 하드코딩을 한다면 아래와 같은 순서로 프로그램을 만들어야 할것입니다.

1. 전체 텍스트를 스플릿을 사용해 공백 문자로 나눕니다
2. 나뉜 단어가 주민등록번호 형식인지 확인한다.
3. 단어가 주민등록번호 형식이라면 뒷자리를 * 로 변환한다.
4. 나뉜 단어를 다시 조립 하도록 한다.

**이 로직을 코드로 구현한다면 아래와 같을 것 입니다.**

```python
data = """
CHOI 910215-1234567
SON  810526-2234567
"""

result = []

## 줄바꿈처리를 기준으로 나눠서 리스트 형식으로 반환된 데이터를 반복문에 넣는다.
for line in data.split("\n"):    
    word_result = [] # 리스트 선언
    for word in line.split(" "): ## 한줄을 다시 공백을 기준으로 나눈다.
        if len(word) == 14 and word[:6].isdigit() and word[7:].isdigit(): #주민등록번호를 확인한다.
            word = word[:6] + "-" + "*******" #뒷자리 변환
        word_result.append(word) 
    result.append(" ".join(word_result))
print("\n".join(result))

```

**그러나 정규식을 사용하면 훨씬 간편하면서도 직관적으로 코드를 작성할 수 있습니다.**

```python
import re 

data = """
CHOI 910215-1234567
SON  810526-2234567
"""

pat = re.compile("(\d{6})[-]\d{7}")
print(pat.sub("\g<1>-*******", data))
```

훨씬 간편하지 않나요? 정규식을 이해한다면 이것이 수백줄 수천줄 코드로 짜여져 있을경우 높은 가독성과 직관적인 코드를 짤 수 있을 것입니다.
또한 찾으려는 문자열 이나 문자열의 규칙이 매우 복잡한 경우에 정규식은 훨씬 강력합니다.

___

# 메타문자.

___
정규 표현식에서 사용하는 메타 문자는 다음과 같습니다.

> . ^ $ * + ? { } [ ] \ | ( )

## 문자 클래스 []

**문자클래스 설명**

- ' [ ] ' 사이의 문자들과 **매치** 라는 의미를 갖음.
- '[abc]' 라면 이 표현식의 의미는 a,b,c 중 한개의 문자와 매치를 뜻함
    - "apple" 이라는 단어는 a를 포함하고있으므로 Matched
    - "fox" 라는 단어는 a,b,c 중 포함하고 있지 않으므로 Unmatched
- '[ ]' 사이에 하이픈을 사용하면 'from - to' 를 의미.
    - '[a-c]' 라는 정규식은 '[abc]' 와 동일함.
    - '[0-5]' 라는 정규식은 '[012345]' 와 동일함.
    - '[a-zA-Z]' : 알파벳 모두를 뜻함.
    - '[0-9]' 숫자를 뜻한다.
- '^' 의 사용은 반대를 의미한다.
    - '[^0-9]' 는 숫자가 아닌 문자만 해당.

**자주사용하는 문자 클래스**
'[0-9]','[a-zA-Z]' 등은 많이 사용되는 정규식이므로 별도의 표기법을 사용할 수 있음.

- ' \d ' : 숫자와 매치,'[0-9]'와 동일한 표현식.
- ' \D'  : 숫자가 아닌 것과 매치, '[^0-9]'와 동일한 표현식.
- ' \s'  : whitespace 문자와 매치, '[\t\n\r\f\v]'와 동일한 표현식입니다. 맨앞의 빈 칸은 공백문자(space)를 의미.
- ' \S'  : whitespace 문자가 아닌 것 과 매치, [^\t\n\r\f\v]와 동일한 표현식.
- ' \w ' : 문자 + 숫자 와 매치, '[a-zA-Z0-9_]' 와 동일한 표현식.
- ' \W ' : 문자 + 수자 가 아닌 매치, '[^a-zA-Z0-9_]'와 동일 한 표현식.

**대문자로 사용은 소문자의 반대임을 알 수 있습니다,**

## Dot(.)

정규 표현식의 Dot(.) 메타 문자는 줄바꿈 문자인 '\n'을 제외한 모드 문자와 매치됨을 의미합니다.

re 라이브러리 사용시 re.DOTALL 옵션을 주면 \n 문자와도 매치됩니다.

1. **'a.b'**

위 정규식은 다음과 같습니다.

**' a + 모든문자 + b '**
즉 a와 b라는 문자 사이에 어떤 문자가 들어가도 모두 매치 된다는 의미 입니다.

- 문자열 "aab","a0b","abc"가 정규식 a.b 와 매치되는지 확인.
    - "aab" 는 가운데 문자 "a"가 모든 문자를 의미하는 . 과 일치하므로 정규식과 매치.
    - "a0b" 는 가운데 문자 "0"이 모든 문자를 의미하는 . 과 일치하므로 정규식과 매치됩니다.
    - "abc" 는 "a"문자와 "b"문자 사이에 어떤 문자라도 하나는 있어야 하는 정규식과 일치 하지 않으므로 매치 되지 않습니다.

2. **'a[.]b''**

이 정규식의 의미는 다음과 같습니다.   
**"a + Dot(.)문자 + b"**

3. 정규식 'a[.]b'는 "a.b" 문자열과 매치되고, "a0b" 문자열과는 매치 되지 않습니다.  
   헷갈릴 수 있는 경우가 있습니다.  
   '[]' 내에 Dot(.) 메타 문자가 사용된다면 문자 '.' 그대로의 의미로 인식해야합니다. 모든문자라는 의미가 아닙니다.

## 반복 '*'

> **ca*t**

이 정규식에는 반복을 의미하는 *메타 문자가 사용되었습니다. 여기에서 사용한 *은 * 바로앞에 있는 문자 a가 0부터 무한대로 반복 될 수 있다는 의미 입니다.

| 정규식  | 문자열   | Match 여부 | 설명                         |
|------|-------|----------|----------------------------|
| ca*t | ct    | Yes      | "a"가 0번 반복되어 매치            |
| ca*t | cat   | Yes      | "a"가 0번 이상 반복되어 매치 (1번 반복) |
| ca*t | caaat | Yes      | "a"가 0번 이상 반복되어 매치 (3번 반복) |

## 반복 '+'

반복을 나타내는 또 다른 메타 문자로 + 가 있습니다. + 는 최소 1번 이상 반복될 때 사용합니다.  
'*'이 반복 횟수가 **0**이라면 +는 반복 횟수 **1**부터 입니다.

다음 정규식을 예제로 사용하겠습니다.

**ca+t**  : "c + a(1번 이상 반복) + t"

매치여부를 표로 표현하면 다음과 같습니다.

| 정규식  | 문자열   | Match | 여부	설명                      |
|------|-------|-------|----------------------------|
| ca+t | ct    | No    | "a"가 0번 반복되어 매치되지 않음       |
| ca+t | cat   | Yes   | "a"가 1번 이상 반복되어 매치 (1번 반복) |
| ca+t | caaat | Yes   | "a"가 1번 이상 반복되어 매치 (3번 반복) |

## 반복 '{m,n}, ?'

- '{ }' 메타 문자를 사용한다면 반복 횟수를 고정 할 수도 있습니다.
- '{m,n}' 정규식을 사용하면 반복 횟수가 m부터 n까지 매치 할 수 습니다.
- m 이나 n을 생략 할수도 있습니다.

> {1,}는 +와 동일하고, {0,}는 *과 동일 합니다.

1. '{m}'
{}을 사용한 몇가지 정규식을 살펴보도록 하겠습니다.

| 정규식    | 문자열  | Match 여부 | 설명                    |
|--------|------|----------|-----------------------|
| ca{2}t | cat  | No       | "a"가 1번만 반복되어 매치되지 않음 |
| ca{2}t | caat | Yes      | "a"가 2번 반복되어 매치       |

2. '{m,n}'
> **ca{2,5}t** : "c + a(2~5회 반복) + t"   

위 정규식에 대한 매치여부는 다음 표와 같습니다.

| 정규식	     | 문자열	      | Match 여부	 | 설명                    |
|----------|-----------|-----------|-----------------------|
| ca{2,5}t | 	cat	     | No	       | "a"가 1번만 반복되어 매치되지 않음 |
| ca{2,5}t | 	caat	    | Yes	      | "a"가 2번 반복되어 매치       |
| ca{2,5}t | 	caaaaat	 | Yes	      | "a"가 5번 반복되어 매치       |

3. '?'
반복은 아니지만 비슷한 개념이 있습니다. ? 는 '{0,1}'를 의미합니다.

> **'ab?c'** : "a + b(있어도 되고 없어도 된다) + c"

|정규식|	문자열|	Match 여부|	설명|
|----------|-----------|-----------|-----------------------|
|ab?c|	abc|	    Yes	 |       "b"가 1번 사용되어 매치|
|ab?c|	ac|	    Yes	     |   "b"가 0번 사용되어 매치|


4. 반복 정리
- 이해하기 쉽고 표현도 간결한 '*', '+', '?' 메타 문자를 사용하는 것이 좋습니다.
- '*', '+', '?' 메타 문자는 모두 {'m', 'n'} 형태로 고쳐 쓰는 것이 가능합니다. 


# re 모듈

## re 의사용
```python
import re

# pattern P
p = re.comple('ab*')
```

re.compile을 사용해 정규식을 컴파일 합니다. re.compile의 결과로 돌려주는 객체 p(컴파일 패턴 객체)를 사용해 그 이후 작업을 수행 합니다.

- 정규식을 컴파일 할 때 특정 옵션을 주는 것도 가능합니다.
- 패턴은 정규식을 컴파일한 결과입니다.

## 문자열검색 with 정규식
컴파일된 패턴객체를 사용해 문자열 검색을 수행합니다.
컴파일된 패턴 객체는 다음과 같은 4가지의 함수 기능을 제공합니다.

| Method	     | 목적                                            |
|-------------|-----------------------------------------------|
| match()	    | 문자열의 처음부터 정규식과 매치되는지 조사한다.                    |
| search()	   | 문자열 전체를 검색하여 정규식과 매치되는지 조사한다.                 |
| findall()	  | 정규식과 매치되는 모든 문자열(substring)을 리스트로 돌려준다.       |
| finditer()	 | 정규식과 매치되는 모든 문자열(substring)을 반복 가능한 객체로 돌려준다. |

match,search 함수는 정규식과 매치 될때 match 객체를 반환하고, 그렇지 않을때는 'None'을 반환합니다.
아래 예제를 통해 직접 살펴 보겠습니다.

```python
import re
p = re.compile('[a-z]+')
```

## match()
- match 함수는 문자열의 처음부터 정규식과 매치되는지 조사합니다. 위에서 선언한 패턴에서 매치 함수를 사용해 보겠습니다.
  ```python
  m = p.match("python")
  print(m) # <re.Match object; span=(0,6), match='python'>  
  ```
"**python**" 문자열은 '[a-z]+' 패턴 정규식에 매치됨으로 match 객체를 반환합니다.

다음은 "3 python" 이라는 문자열을 매치함수로 적용 시켜보겠습니다.

```python
m = p.match("3 python")
print(m) # None
```

"none"을 반환 하는 것을 확인해 볼 수 있습니다.

매치의 결과로 match 객체 또는 None을 똘려주기 때문에 파이썬 정규식 프로그램은 다음과같이 조건문인 if문을 추가하여 다음과 같은 흐름으로 작성합니다.

```python
p = re.compile({정규표현식})
m = p.match( 'string goes here' )
if m:
    print('Match found: ', m.group())
else:
    print('No match')

```

## search()

컴파일된 패턴 객체 p를 가지고 search 함수를 사용해 보도록 하겠습니다.

```python
m = p.search("python")
print(m) # <re.Match object; span=(0, 6), match='python'>
```

match함수는 None을 반환 했지만 Search함수는 문자열 전체에서 패턴을 검색했기 때문에 match를 반환 하였습니다.

match 함수와 search 함수는 문자열의 청므부터 검색할지 의 여부에 따라 다르게 사용해야 합니다.


## findall()
```python
result = p.findall("I deream code python everyday")
print(result) #['deream', 'code', 'python', 'everyday']
```

"I deream code python everyday" 문자열의 'deream', 'code', 'python', 'everyday' 단어를 p 패턴으로 설정한 '[a-z]+' 정규식과 매치해서 리스트로 반환합니다.
대문자 패턴은 입력하지 않았으므로 "I"는 리스트에 반환 시키지 않았습니다.


## finditer()
이번에는 finditer 함수를 실행시켜 보도록 하겠습니다.
```python
result = p.finditer("life is too short")
print(result) # <callable_iterator object at 0x0000017F83444820>

for r in result: print(r)

# 결과값은 아래와 같습니다.
# <re.Match object; span=(2, 8), match='deream'>
# <re.Match object; span=(9, 13), match='code'>
# <re.Match object; span=(14, 20), match='python'>
# <re.Match object; span=(21, 29), match='everyday'>
```
finditer는 findall과 동이랗지만 그 결과로 반복 가능한 객체를 반환하도록합니다.

반복 가능한 객체가 포함하는 각각의 요소는 match 객체입니다.

## match 객체의 함수.
이제 match함수의 search메서드를 수행한 결과로 돌려준 amtch 객체에 대해서 알아보도록 하겠습니다.
앞에서 정규식을 사용한 문자열 검색을 수행하면서 알아보도록 하겠습니다.

- 어떤 문자열이 매치되었는지.
- 매치된 문자열의 인덱스 위치는 어디서 부터 어디까지 인지.

match 객체의 메서드를 사용하면 다음과 같은 데이터의 정보를 얻을 수 있습니다.

| method	 | 목적                               |
|---------|----------------------------------|
| group() | 	매치된 문자열을 돌려준다.                  |
| start() | 	매치된 문자열의 시작 위치를 돌려준다.           |
| end()	  | 매치된 문자열의 끝 위치를 돌려준다.             |
| span()	 | 매치된 문자열의 (시작, 끝)에 해당하는 튜플을 돌려준다. |

```python

 m = p.match("python")
 m.group() # 'python' 
 m.start() # 0
 m.end() # 6
 m.span() # (0, 6)
```
예상한 대로 결과 값이 출력되는 것을 확인 할 수 있습니다. search 함수를 이용했다면 start() 값은 다르게 나올 수있습니다.

```python
m = p.search("3 python")
m.group() # 'python'
m.start() # 2
m.end() # 8
m.span() # (2, 8) 
```

# 모듈 단위로 수행해보기

```python
p = re.compile('[a-z]+') # 문자열의 패턴을 가진 패턴을 지정합니다.
m = p.match("python")
```
**코드**를 축약 하면 **다음**과 같습니다.
```python
m=re.match('[a-z]+',"python")
```
위에서 처럼 사용하면 컴파일과 함수를 한 번에 수행 할 수 있습니다. 보통 한번 만든 패턴 객체를 여러번 사용해야 할 떄는 이방법보다 컴파일을 지정해 주는 것이 훨씬 바람직 합니다.

## 컴파일 옵션
정규식을 컴파일 선언시에 다음의 옵션을 사용할 수있습니다.
- DOTALL(S) = .이 줄바꿈 문자를 포함해 모든 문자와 매치 할 수 있도록 합니다.
- IGNORECASE(I) - 대소문자에 관계없이 매치할 수 있도록합니다.
- MULTILINE(M) - 여러줄과 매치할 수 있도록 합니다. (^,$메타문자의 사용과 관계가 있는 옵션입니다.)
- VERBOSE(X) -VERbose 모드를 사용할 수 있도록 합니다.(정규식을 보기 편하게 만들수도 있고, 주석등을 사용할 수 있습니다.)

옵션을 사용할때는 're.DOTALL' 로 전체 옵션에 이름을 써도되고 're.s' 약어를 써도 가능합니다.

## DOTALL, S
'.'메타 문자는 줄바꿈 문자 '\n' 을 제외한 모든 문자와 매치되는 규칙이 있습니다.   
만약에 '\n' 문자도 포함해 매치하고 싶다면 're.DOTALL' 또는 're.s' 옵션을 사용해 정규식을 컴파일 하면 됩니다.

예제 코드를 살펴보도록 하겠습니다.

```python
import re
p = re.compile('a.b')
m = p.match('a\nb')
print(m) # None
```
\n 문자와도 매치되게 하려면 다음과 같이 re.DOTALL 옵션을 사용해야 합니다.

```python
p = re.compile('a.b', re.DOTALL)
m = p.match('a\nb')
print(m) <re.Match object; span=(0, 3), match='a\nb'>
```
보통 're.DOTALL' 옵션은 여러 줄로 이루어진 문자열에서 줄바꿈처리가 상관없이 검색할 때 많이 사용합니다.

## GINORECASE, I
're.IGNORECASE' 또는 're.I' 옵션은 대소문자 구별 없이 매치를 수행할 때 사용하는 옵션입니다.

```python
p = re.compile('[a-z]+', re.I)
p.match('python') # <re.Match object; span=(0, 6), match='python'>
p.match('Python') # <re.Match object; span=(0, 6), match='Python'>
p.match('PYTHON') # <re.Match object; span=(0, 6), match='PYTHON'>
```
'[a-z]+' 정규식은 소문자만을 의미하지만 re.I 옵션으로 대소문자를 구별없이 매치 할 수 있습니다.


## MULTILINE, M

re.MULTILINE 또는 re.M 옵션은 '^','$'와 연관된 옵션입니다. 
- '^' 메타 문자는 문자열의 처음을 의미합니다.
- '$' 메타 문자는 문자열의 마지막을 의미합니다.
- '^python' 인경우 문자열의 처음은 python으로 시작해야 매치가 됩니다.
- 'python$' 인경우 문자열의  끝 은 python으로 끝이나야 매치가 됩니다.

```python
import re
p = re.compile("^python\s\w+")

data = """
python one
I dream code python everyday
python two
you need python
python three
"""

print(p.findall(data))
```

위 정규식을 잘 해석 해보면 정규식 '^python\s\w+'는 
- 'python'이라는 문자열로 시작한다. '^python'
- 다음에는 공백이온다 '^python\s'
- 그뒤에 단어가 와야한다 '^python\s\w+'

**'^'** 문자를 각라인의 처음으로 인식시키고 싶은 경우에 사용할 수 있는 옵션이 're.MULTILINE' 또는 're.M' 입니다.  
코드는 다음과 같습니다.
```python
import re
p = re.compile("^python\s\w+", re.MULTILINE)

data = """python one
I dream code python everyday
python two
you need python
python three"""

print(p.findall(data))
# ['python one', 'python two', 'python three']
```

> 코드의 세계는 신비롭지 않나요.
처음에 정규식을 잘 사용할 줄 몰랐을때에는 포기하고 string을 기교를 부리며 하드코딩 한적이 많았습니다.   
그럴때마다 한계에 부딪히고는 했습니다. 그러나 정규식을 잘사용한다면 많은 에너지 소모를 줄일 수 있지 않나 생각해봅니다.


## VERBOSE, X
정규식 전문가들이 만든 정규식을 보면 거의 암호 수준입니다.    
정규식을 이해하려면 하나하나 뜯어보아야합니다.  
여기에 주석을 추가 할 수있다면 가독성이 추가됨으로 훨씬 빠른 이해를 도울 수있습니다. 

이떄 바로 필요한것이 **re.VERBOSE** 입니다.

```python
charref = re.compile(r'&[#](0[0-7]+|[0-9]+|x[0-9a-fA-F]+);')
```

위와같은 코드의 정규식은 실제로 이해하기 어렵습니다. 따라서 다음과 같은 예제로 풀어보도록 하겠습니다.

```python
charref = re.compile(r"""
 &[#]                # Start of a numeric entity reference
 (
     0[0-7]+         # Octal form
   | [0-9]+          # Decimal form
   | x[0-9a-fA-F]+   # Hexadecimal form
 )
 ;                   # Trailing semicolon
""", re.VERBOSE)
```
- re.VERBOSE 옵션을 사요하면 문자열에 사용된 whitespace는 컴파일 할때 제거됩니다.('[]' 안에서 사용한 whitespace는 제외 입니다.)
-  줄단위로 '#'을 사용해 주석을 작성 할 수있습니다. 

## 백슬러시 문제
정규 표현식을 파이썬에서 사용할 때 혼란을 주는 요소가 한 가지 있는데, 바로 백 슬러시(\) 입니다.  
예를 들어 어떤 파일 안에 있는 "\section" 문자열을 찾기 위한 정규식을 만든다고 가정해 봅시다.

**\section**

이 정규식은 '\s'문자가 whitespace로 해석되어 의도한 대로 매치가 이루어지지 않습니다.
위 표현은 다음과 같이 동일한 이ㅡ미가 됩니다.
'[ \t\n\r\f\v]'ection

의도한 대로 매치하고 싶다면 다음과 같이 변경해야 합니다.
**\\section**

정규식에서 사용한 \문자가 문자열 자체임을 알려 주기 위해서 백슬래시 2개를 사용해 escape 탈출 처리 해야합니다.
따라서 위 정규식을 컴파일 하려면 다음과 같이 작성 하도록합니다.

```python
p = re.compile('\\section') # 문제발생 >> '\\\\section'으로 사용해야 \\section을 인식.
```
- 그러나 여기에서 또하나의 문제가 발견됩니다. 
- 위처럼 정규식을 만들어서  컴파일 하게된다면 실제로 문제가 발생합니다. 
- 파이썬 정규식 엔진에는 파이썬 문자열 리터럴 규칙에 따라서 \\이 \로 변경되어 '\section'이 전달됩니다. 
- 결국 '\\\\section' 으로 백슬러시를 4개나 사용해야 합니다.  
>※ 이 문제는 위와 같은 정규식을 파이썬에서 사용할 때만 발생한다(파이썬의 리터럴 규칙). 유닉스의 grep, vi 등에서는 이러한 문제가 없습니다.  


위와 같은 문제로 파이썬 정규식에는 Raw String 규칙이 생겨나게 되었습니다. 컴파일 해야하는 정규식이 RawString임을 알려 줄 수있도록 문법을 만든것입니다. 그 방법은 다음과 같습니다.
```python
p = re.compile(r'\\section')
```

위와 같이 정규식 문자열 앞에 r문자를 삽입시 Raw String 규칙에 의해 백슬래시 2개 대신 1개만 써도 2개를 쓴 것과 동일한 의미를 갖게 됩니다.


[참고 : 점프 투 파이썬](https://wikidocs.net/1642)